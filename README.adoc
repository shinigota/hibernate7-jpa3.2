= Hibernate 7 & JPA 3.2
:toc: auto

== Intro

https://hibernate.org/orm/releases/7.0/[Hibernate 7], sorti le 19/05 implémente https://projects.eclipse.org/projects/ee4j.jpa/releases/3.2[JPA dans sa version 3.2], sorti le 30/04.

Ces deux releases majeures apportent leur lot de nouveautés, certaines mêmes incontournables.

L'étude présente les features, en utilisant nativement JPA et Hibernate, sans Spring Data ou autre librairie.

D'une part, Spring n'est pour le moment pas compatible JPA 3.2/Hibernate 7 (https://spring.io/blog/2024/10/01/from-spring-framework-6-2-to-7-0[compatibilité prévue pour Spring 7]), d'autre part, pour mieux comprendre les nouveaux mécanismes de Hibernate et JPA il est plus pertinent de mettre de côté une surcouche comme Spring Data JPA.

L'étude contient un projet Java 21 servant d'exemple aux nouveautés. Il se consacre davantage à Hibernate plutôt qu'à JPA. Le starter web de Spring Boot est utilisé, uniquement pour la partie injection de dépendance et avoir une IHM d'administration de la base de données h2 embarquée. +
Ni Spring Data JPA ni Spring JDBC ou autre librairie que Hibernate sont utilisées pour l'accès à la BDD.

== https://in.relation.to/2024/04/01/jakarta-persistence-3/[JPA 3.2]

=== Configuration

Historiquement, JPA se configurait uniquement depuis un fichier `persistence.xml`.

JPA 3.2 propose une configuration par du code.

[source,java]
----
EntityManagerFactory emf =
    new PersistenceConfiguration("Bookshop")
                .nonJtaDataSource("java:global/jdbc/BookshopData")
                .managedClass(Book.class)
                .property(PersistenceConfiguration.LOCK_TIMEOUT, 5000)
                .createEntityManagerFactory();
----

L'objet peut être déclaré dans un bean Spring par exemple. +
Ensuite, on peut déclarer un `EntityManager` qu'on utilise de manière habituelle avec JPA :

[source,java]
----
EntityManager em = emf.createEntityManager();
try (EntityManager em = emf.createEntityManager()) {
    em.getTransaction().begin();

    em.persist(...);
    em.find(..., ...);

    em.getTransaction().commit();
} catch (Exception e) {
    em.getTransaction().rollback();
}

----

*Résumé* : Cette évolution pourrait rendre possible la création d'une configuration JPA dynamique, ce qui n'était pas possible depuis un XML statique par nature.

=== Méthodes de gestion automatique des transaction

Pour éviter d'ouvrir une transaction, commit, rollback en cas d'exception et fermer l'`EntityManager` à chaque fois, JPA propose des nouvelles méthodes fonctionnelles :

- `EntityManagerFactory.runInTransaction` : gère automatiquement le cycle de vie de `EntityManager`, pour les requêtes sans retour (INSERT, DELETE, UPDATE)
- `EntityManagerFactory.callInTransaction`: gère automatiquement le cycle de vie de `EntityManager`, pour les requêtes ave retour (SELECT)
- `EntityManager.runWithConnection` : *À partir d'un `EntityManager`*, gère le cycle de vie d'une connexion JDBC, pour des requêtes SQL natives

Ces fonctions prennent chacune une lambda : l'appel à exécuter. La transaction est gérée automatiquement pour plus de lisibilité.

[source,java]
----
/** runInTransaction quand il s'agit d'une requête qui ne retourne rien **/
entityManagerFactory.runInTransaction( entityManager -> {
    Book b = entityManager.find(Book.class, id);
    entityManager.remove(b);
});

/** callInTransaction quand il s'agit d'une requête avec un retour, un SELECT par exemple **/
Book b = entityManagerFactory.callInTransaction( entityManager -> {
    return entityManager.find(Book.class, id);
});

/** Et runWithConnection, quand du SQL natif doit être joué (procédure stockée par exemple)
    attention, runWithConnection nécessite un EntityManager et non EntityManagerFactory !
    On peut justement chainer EntityManagerFactory.runInTransaction et EntityManager.runWithConnection !  **/
entityManagerFactory.runInTransaction(em ->
    em.runWithConnection(connection -> {
        try (Statement s = ((Connection) connection).createStatement()) {
            s.execute("SELECT 1 FROM DUAL");
        }

        try (PreparedStatement s = ((Connection) connection).prepareStatement("SELECT * FROM DUAL WHERE DUMMY = ?")) {
            s.setString(1, "X");
            s.execute();
        }

        try (CallableStatement s = ((Connection) connection).prepareCall("{call package(?)}")) {
            s.setString(1, "arg");
            s.execute();
        }
    })
);
----

*Résumé* : Cette nouvelle feature est la bienvenue, elle rend la gestion de transaction et session bien plus simple et automatique, globalement est code est bien plus lisible.

=== Metamodel

Historiquement, la définition de `Criterias` passait par l'usage, en dur, des noms des tables, colonnes et la définition manuelle des types.

[source,java]
----
List<Shop> shops = this.sessionFactory.callInTransaction(em -> {
            CriteriaBuilder cb = em.getCriteriaBuilder();
            CriteriaQuery<Shop> cr = cb.createQuery(Shop.class);
            Root<Shop> root = cr.from(Shop.class);
            cr.select(root);
            cr.where(
                    cb.and(
                            cb.equal(root.<Long>get("id"), ownerId),
                            cb.equal(root.<Address>get("address").<String>get("city"), "Pessac")));

            return em
                    .createQuery(cr)
                    .setHint("jakarta.persistence.fetchgraph", em.getEntityGraph("Shop.withEmployees"))
                    .getResultList();

        });
----

Cela induisait plusieurs complexités :
- `root.<Long>get("id")` : Le nom de la colonne est en dur. Une variable statique peut être créée mais si le nom de la colonne vient à changer, la variable doit être mise à jour

- `<Long>get(...)` : Il est de la responsabilité du développeur de typer correctement l'appel en passant le type générique, ce qui en plus d'être verbeux, peut être source d'erreur (rien n'empêche un mauvais cast) et les mêmes problèmes se posent en cas de refactoring. En pratique, le type générique est souvent omis et on se retrouve avec des warnings dans le code et un code potentiellement imprévisible

Le métamodel est une solution existante depuis JPA 2. En effet, notre ORM implémentant JPA 2 doit permettre de générer des classes *metamodel*, décrivant les colonnes et types de chaque classes.

Un simple ajout de la dépendance permettra de générer les classes *metamodel* pour chaque entité, lors du build

[source,xml]
----
<dependency>
    <groupId>org.hibernate.orm</groupId>
    <artifactId>hibernate-processor</artifactId>
    <version>7.0.3.Final</version>
</dependency>
----

[source,java]
----
@StaticMetamodel(Book.class)
public abstract class Book_ {
    public static final String ID = "id";
    public static final String TITLE = "title";
    public static final String AUTHOR = "author";
    public static final String SHOPS = "shops";
    public static volatile EntityType<Book> class_;
    public static volatile SingularAttribute<Book, Long> id;
    public static volatile SingularAttribute<Book, String> title;
    public static volatile SingularAttribute<Book, Person> author;
    public static volatile CollectionAttribute<Book, Shop> shops;

    public Book_() {
    }
}
----

Cette classe peut ensuite être utilisée dans l'API Criteria, pour s'affranchir des noms de colonnes et types en durs. Plus de risques liés aux types et aux refactoring, le metamodel est géré automatiquement :
[source,java]
----
List<Shop> shops = this.sessionFactory.callInTransaction(em -> {
    CriteriaBuilder cb = em.getCriteriaBuilder();
    CriteriaQuery<Shop> cr = cb.createQuery(Shop.class);
    Root<Shop> root = cr.from(Shop.class);
    cr.select(root);
    cr.where(
            cb.and(
                    cb.equal(root.get(Shop_.owner), ownerId),
                    cb.equal(root.get(Shop_.address).get(Address_.city), "Pessac")));

    return em
            .createQuery(cr)
            .setHint("jakarta.persistence.fetchgraph", em.getEntityGraph("Shop.withEmployees"))
            .getResultList();

});
----

Par exemple, `root.<Address>get("address").<String>get("city")` devient `root.get(Shop_.address).get(Address_.city)`.

Ici, deux nouveautés sur JPA 3.2 sont les constantes contenant le nom des propriétés, entityGraphs nommés, requêtes nommées, mapping de resulset SQL natif ...

[source,java]
----
public static final String ID = "id";
public static final String ADDRESS = "address";
public static final String OWNER = "owner";
public static final String EMPLOYEES = "employees";
public static final String BOOKS = "books";
public static final String QUERY_SHOP_FIND_ALL_BY_OWNER_ID = "Shop.findAllByOwnerId";
----

Le principe est toujours le même, plutôt que référencer l'objet en dur avec son nom, on passe par la constante.

L'entité :
[source,java]
----
@NamedEntityGraph(
        name = "Shop.withEmployees.nativeJpa",
        attributeNodes = @NamedAttributeNode("employees")
)
@NamedQuery(name = "Shop.findAllByOwnerId", query = "SELECT s FROM Shop s WHERE s.owner.id = :id")
public class Shop {
    @Id
    @GeneratedValue
    private Long id;

    @Embedded
    private Address address;

    // ...
}
----

Le métamodel :
[source,java]
----
    public static final String ID = "id";
    public static final String ADDRESS = "address";
    public static final String OWNER = "owner";
    public static final String EMPLOYEES = "employees";
    public static final String BOOKS = "books";
    public static final String QUERY_SHOP_FIND_ALL_BY_OWNER_ID = "Shop.findAllByOwnerId";
    public static final String GRAPH_SHOP_WITH_EMPLOYEES_NATIVE_JPA = "Shop.withEmployees.nativeJpa";
----

L'utilisation :
[source,java]
----
// Dans l'entité
@ManyToMany(mappedBy=Shop_.AUTHORS, fetch = FetchType.LAZY)
Collection<Person> employees;

// Dans le service
List<Shop> shops =  this.sessionFactory.callInTransaction( em ->
        em.createNamedQuery(Shop_.QUERY_SHOP_FIND_ALL_BY_OWNER_ID)
                .setParameter("id", ownerId)
                .setHint("jakarta.persistence.fetchgraph", Shop_.GRAPH_SHOP_WITH_EMPLOYEES_NATIVE_JPA)
                .getResultList());
----

*Résumé* : Le metamodel s'enrichit. En principe, il se génère automatiquement et permet de s'affranchir de certains problèmes, donc il n'y a absolument aucune raison à ne pas l'utiliser. Maintenant que tous les objets "nommés" sont disponibles (propriétés/colonnes, entity graphs, requêtes, mapping SQL), l'utilisation du metamodel est bien plus cohérente et on peut au maximum éviter les strings / types en durs.

== Hibernate 7
=== @EmbeddedColumnNaming

Les types embarqués existent depuis un moment mais étaient limités.

Ils permettent de découper une table avec de nombreuses colonnes en plusieurs objets.
Typiquement, une table "Personnes" aura des colonnes pour son adresse (rue, code postal, ...)

|===
| id | first_name | last_name | city | street | zip_code
| | | | | |
|===

L'entité peut être découpée avec son type embarqué :

[source,java]
----
@Entity
@Table(name = "Personnes")
public class Person {
    @Id
    @GeneratedValue
    private Long id;

    private String firstName;

    private String lastName;

    @Embedded
    private Address address;

    //...
}

@Embeddable
public class Address {
    private String city;

    private String street;

    private String zipCode;
}
----

Cependant, jusqu'à Hibernate 7, les types embarqués étaient limités.

En effet, le mapping se faisait exclusivement avec le nom des propriétés (qui devaient correspondre au nom des colonnes en BDD).
Dans le cas où notre personne dispose de plusieurs adresses, les `@Embedded` n'étaient pas possible, sans https://docs.jboss.org/hibernate/orm/7.0/userguide/html_single/Hibernate_User_Guide.html#embeddable-override[solution de contournement complexe et extrêmement verbeuse] (utilisation de `@AttributeOverride` et `@AttributeOverrides`).

Pour remédier à ce problème, Hibernate 7 propose `@EmbeddedColumnNaming`, permettant d'utiliser plusieurs fois le même type embarqué avec un pattern:

[source,java]
----
@Entity
@Table(name = "Personnes")
public class Person {
    @Id
    @GeneratedValue
    private Long id;

    private String firstName;

    private String lastName;

    @Embedded
    @EmbeddedColumnNaming("home_%s")
    private Address homeAddress;

    @Embedded
    @EmbeddedColumnNaming("work_%s")
    private Address workAddress;

    //...
}

@Embeddable
public class Address {
    private String city;

    private String street;

    private String zipCode;
}
----

Les patterns `home_%` et `work_%` impliquent une table initialisée de cette manière :

|===
| id | first_name | last_name | home_city | home_street | home_zip_code | work_city | work_street | work_zip_code
| | | | | | | | |
|===

*Résumé* : Le type `Embedabble` est maintenant utilisable plusieurs fois dans un même objet, cette évolution ne sera peut être pas utile tout le temps, mais elle est la bienvenue !

=== @NamedEntityGraph

Le problème N+1 est bien connu, est compliqué à contourner et a un gros impact sur les performances d'une application:

- En mode eager lorsqu'on récupère un objet, ses associations sont récupérées, les associations des associations sont elles mêmes récupérées ... quand en réalité, on a besoin uniquement de quelques colonnes. Les performances peuvent vite devenir désastreuses ...
- En mode lazy, il faut initialiser les propriétés à la main, ce qui est fastidieux à mettre en place et à maintenir. Le coût en performance est important, pour chaque association à initialiser, une nouvelle requête sera jouée, *c'est là qu'apparaît le problème N+1* . De plus, lorsqu'on a besoin de la donnée, on se retrouve souvent dans une portion de code où il n'y a plus de contexte de persistence (ou session au sens Hibernate) ce qui devient souvent casse tête et pousse à produire du code un peu n'importe où, pourvu que ca passe et qu'une session soit ouverte...
- Lorsqu'on mixe les deux (certaines associations en eager, d'autres en lazy), on se retrouve dans des cas où, pour une autre IHM, on a besoin de charger des associations différentes : quoi qu'il arrive, le casse tête est incessant ...

Plusieurs solutions existent :

- Écrire des requêtes `JPQL` pour chaque cas et utiliser https://www.baeldung.com/jpa-join-types#fetch[JOIN FETCH] : Fonctionne bien mais nécessite de faire des requêtes JPQL difficilement réutilisables, un peu partout.
- Utiliser https://docs.jboss.org/hibernate/orm/6.5/javadocs/org/hibernate/annotations/BatchSize.html[@BatchSize] : ne règle pas directement le problème, mais permet de réduire grandement le nombre de requêtes lancées (au lieu de récupérer les associations unes par unes, on les récupères par lots de X)
- Dupliquer des entités, mapper les propriétés autrement (faire l'équivalent de vues SQL): verbeux, nécessite de dupliquer et si une table change, risque d'impact sur un plus grand nombre de classes
- Finalement, les https://www.baeldung.com/jpa-entity-graph[EntityGraph], permettant de définir au travers d'un objet, l'arbre d'association à initialiser. Ce qui est flexible, car réutilisable dans la plupart des méthodes (criteria, find, méthodes de pagination) là où une requête JPQL est plus difficilement réutilisable.

Les `EntityGraph` sont une solution élégante (le `join fetch` existe aussi), existant depuis un moment mais enfin "simples" à utiliser grace à la nouvelle annotation `@NamedEntityGraph` (une annotation JPA du même nom existe depuis plus longtemps, nous parlons ici de celle d'Hibernate, beaucoup plus simple à utiliser).

Le principe est le suivant : on initialise un graph, au format String, il décrit quelles seront les associations à récupérer directement dans la requête jouée par Hibernate.

[source, java]
----
@Entity
@Table(name = "Shops")
@NamedEntityGraph(name = "Shop.withEmployees", graph = "employees")
@NamedEntityGraph(name = "Shop.withBooksAndTheirAuthor", graph = "books(author)")
public class Shop {
    @Id
    @GeneratedValue
    private Long id;

    @Embedded
    private Address address;

    @ManyToOne(fetch = FetchType.LAZY)
    private Person owner;

    @ManyToMany(fetch = FetchType.LAZY)
    private Collection<Person> employees;

    @ManyToMany(fetch = FetchType.LAZY)
    private Collection<Book> books;
}
----

Ici, par défaut on peut mettre toutes les associations en `LAZY`, on initialise plusieurs `@NamedEntityGraph`, dans lesquels on spécifie quelles associations sont à initialiser :

- Un graph pour récupérer les `Shop` avec leurs `employees` (étant une association de type `@ManyToMany`)
- Un graph pour récupérer les `Shop` avec leurs `books`(étant une association de `Shop`) et avec leurs `author` (étant eux même une association de `Book`) : il s'agit de graphe, on peut imbriquer autant d'associations qu'on veut.

Pour exécuter l'entity graph :

[source, java]
----
// cas d'un findById
Shop s1, s2;
// Cas classique, sans entity graph
s1 = session.find(id);
// Avec entity graph
EntityGraph<Shop> entityGraph1 = (EntityGraph<Shop>) session.getEntityGraph("Shop.withEmployees");
s2 = session.find(entityGraph1, id);

// cas d'un findAll
List<Shop> l1, l2;
// Cas classique, sans entity graph
l1 = session
    .createQuery("from Shop")
    .getResultList();
// Avec entity graph
EntityGraph<Shop> entityGraph2 = (EntityGraph<Shop>) session.getEntityGraph("Shop.withBooksAndTheirAuthor");
l2 = session
    .createQuery("from Shop")
    .setHint("jakarta.persistence.fetchgraph", entityGraph2)
    .getResultList();
----

L'intérêt est qu'on peut facilement choisir quelles associations seront chargées, pour afficher par exemple deux IHM différentes : un tableau affichant les boutiques et leurs employés, un autre affichant les boutiques, leurs livres et auteurs.

*Remarque :* la documentation suggère qu'il est aussi possible d'inclure des propriétés "classiques" dans le graphe : c'est à dire lazy load des colonnes et non uniquement des associations. Même si JPA le permet, cela dépend de la librairie qui l'implémente et par défaut Hibernate ne permet pas de lazy loader des propriétés ! +
Voir <<note1>>

*Résumé* : Sans doute l'évolution la plus importante à retenir ! Les EntityGraph de JPA sont assez complexes à prendre en main mais sont pourtant une solution efficace et flexible concernant le problème N+1. Cette nouvelle annotation rend le principe d'EntityGraph plutôt simple à prendre en main. Point d'attention en revanche, le `@NamedEntityGraph` d'hibernate ne doit pas être confondu avec le `@NamedEntityGraph` de JPA, une différence notable est que le `@NamedEntityGraph` d'Hibernate n'est pas disponible dans le metamodel.

== Remarques

=== Remarques sur le lazy load Hibernate [[note1]]

La https://docs.jboss.org/hibernate/orm/7.0/userguide/html_single/Hibernate_User_Guide.html#fetching-strategies-dynamic-fetching-entity-graph-parsing-annotation[documentation sur les `@NamedEntityGraph`] suggère qu'il est possible de lazy-load des propriétés (en plus des associations) :

[source,java]
----
@Entity
@NamedEntityGraph( graph="title,isbn,author(name,phoneNumber)" )
class Book {
// ...
}
----

Ici, on ne charge que les propriétés `title` et `isbn`. Pour les auteurs, on ne charge que `name` et `phoneNumber` : le reste sera à null.

Ce n'est pourtant pas possible :

Une https://docs.jboss.org/hibernate/orm/7.0/userguide/html_single/Hibernate_User_Guide.html#basic-basic-annotation[annotation] `@Basic(optional = true, fetch = FetchType.LAZY)` (qui est facultative) est disponible pour la mettre sur les propriétés "classiques".

[source,java]
----
@Entity
@Table(name = "Personnes")
public class Person {
    @Id
    @GeneratedValue
    private Long id;

    @Basic(fetch = FetchType.LAZY)
    private String firstName;

    @Basic(fetch = FetchType.LAZY)
    private String lastName;
}
----

C'est une annotation *JPA* et non *Hibernate*. Le paramètre `fetch` n'est, d'après la documentation, qu'un hint donné à JPA, mais la capacitié de lazy-loader une *propriété*  est au final le choix de l'implémentation, ici Hibernate et non de JPA.

Par défaut, Hibernate ignore ce paramètre, à moins d'activer le plugin https://docs.jboss.org/hibernate/orm/7.0/userguide/html_single/Hibernate_User_Guide.html#BytecodeEnhancement[bytecode enhancement] et mettre la propriété `enableLazyInitialization` à `true`.

[source,xml]
----
<build>
		<plugins>
            ...
			<plugin>
				<groupId>org.hibernate.orm.tooling</groupId>
				<artifactId>hibernate-enhance-maven-plugin</artifactId>
<!-- Il faut mettre EXACTEMENT la même version que la dépendance hibernate ! -->

				<version>7.0.0.Beta1</version>
				<executions>
					<execution>
						<configuration>
							<failOnError>true</failOnError>
							<enableLazyInitialization>true</enableLazyInitialization>
						</configuration>
						<goals>
							<goal>enhance</goal>
						</goals>
					</execution>
				</executions>
			</plugin>
		</plugins>
	</build>
----

Et ce plugin n'est disponible qu'en Beta et non en version finale, causant aujourd'hui des problèmes de compatibilité :

Le lazy load sur Hibernate par défaut se limite aux *associations* et il est conseillé de rester sur ce fonctionnement.

Donc il vaut mieux considérer le lazy load de propriété, sur les EntityGraph impossible
